{
    "collab_server" : "",
    "contents" : "spamPath = system.file(package = \"RSpamData\")\n#spamPath = \"/Users/nolan/RPackages/RSpamData\"spamPath = \".\"\nsetwd(\"/Users/rsimham/Desktop/SMU/QTW/Week5/SpamAssassinMessages/\")\ngetwd()\nlist.dirs(spamPath, full.names = FALSE)\n\nlist.files(path = paste(spamPath, \"SpamAssassinMessages\", sep = .Platform$file.sep))\n\nhead(list.files(path = paste(spamPath, \"messages\", \"spam_2\", sep = .Platform$file.sep)))\n\ndirNames = list.files(path = paste(spamPath, \"messages\", \n                                   sep = .Platform$file.sep))\nlength(list.files(paste(spamPath, \"messages\", dirNames, \n                        sep = .Platform$file.sep)))\n\nsapply(paste(spamPath, \"messages\", dirNames, \n             sep = .Platform$file.sep), \n       function(dir) length(list.files(dir)) )\n\nfullDirNames = paste(spamPath, \"messages\", dirNames, \n                     sep = .Platform$file.sep)\n\nfileNames = list.files(fullDirNames[1], full.names = TRUE)\nfileNames[1]\n\nmsg = readLines(fileNames[1])\nhead(msg)\n\nindx = c(1:5, 15, 27, 68, 69, 329, 404, 427, 516, 852, 971)\nfn = list.files(fullDirNames[1], full.names = TRUE)[indx]\nsampleEmail = sapply(fn, readLines)        \n\nmsg = sampleEmail[[1]]\nwhich(msg == \"\")[1]\n\nmatch(\"\", msg)\n\nsplitPoint = match(\"\", msg)\n\nmsg[ (splitPoint - 2):(splitPoint + 6) ]\n\nheader = msg[1:(splitPoint-1)]\nbody = msg[ -(1:splitPoint) ]\n\nsplitMessage = function(msg) {\n  splitPoint = match(\"\", msg)\n  header = msg[1:(splitPoint-1)]\n  body = msg[ -(1:splitPoint) ]\n  return(list(header = header, body = body))\n}\n\nsampleSplit = lapply(sampleEmail, splitMessage)\n\nheader = sampleSplit[[1]]$header\ngrep(\"Content-Type\", header)\n\ngrep(\"multi\", tolower(header[46]))\n\nheader[46]\n\nheaderList = lapply(sampleSplit, function(msg) msg$header)\nCTloc = sapply(headerList, grep, pattern = \"Content-Type\")\nCTloc\n\nsapply(headerList, function(header) {\n  CTloc = grep(\"Content-Type\", header)\n  if (length(CTloc) == 0) return(NA)\n  CTloc\n})\n\nhasAttach = sapply(headerList, function(header) {\n  CTloc = grep(\"Content-Type\", header)\n  if (length(CTloc) == 0) return(FALSE)\n  grepl(\"multi\", tolower(header[CTloc])) \n})\n\nhasAttach\n\nheader = sampleSplit[[6]]$header\nboundaryIdx = grep(\"boundary=\", header)\nheader[boundaryIdx]\n\nsub(\".*boundary=\\\"(.*)\\\";.*\", \"\\\\1\", header[boundaryIdx])\n\nheader2 = headerList[[9]]\nboundaryIdx2 = grep(\"boundary=\", header2)\nheader2[boundaryIdx2]\n\nsub('.*boundary=\"(.*)\";.*', \"\\\\1\", header2[boundaryIdx2])\n\nboundary2 = gsub('\"', \"\", header2[boundaryIdx2])\n\nsub(\".*boundary= *(.*);?.*\", \"\\\\1\", boundary2)\n\nboundary = gsub('\"', \"\", header[boundaryIdx])\nsub(\".*boundary= *(.*);?.*\", \"\\\\1\", boundary)\n\nsub(\".*boundary= *([^;]*);?.*\", \"\\\\1\", boundary)\n\ngetBoundary = function(header) {\n  boundaryIdx = grep(\"boundary=\", header)\n  boundary = gsub('\"', \"\", header[boundaryIdx])\n  gsub(\".*boundary= *([^;]*);?.*\", \"\\\\1\", boundary)\n}\n\nsampleSplit[[6]]$body\n\nboundary = getBoundary(headerList[[15]]) \nbody = sampleSplit[[15]]$body\n\nbString = paste(\"--\", boundary, sep = \"\")\nbStringLocs = which(bString == body)\nbStringLocs\n\neString = paste(\"--\", boundary, \"--\", sep = \"\")\neStringLoc = which(eString == body)\neStringLoc\n\nmsg = body[ (bStringLocs[1] + 1) : (bStringLocs[2] - 1)]\ntail(msg)\n\nmsg = c(msg, body[ (eStringLoc + 1) : length(body) ])\ntail(msg)\n\ndropAttach = function(body, boundary){\n  \n  bString = paste(\"--\", boundary, sep = \"\")\n  bStringLocs = which(bString == body)\n  \n  if (length(bStringLocs) <= 1) return(body)\n  \n  eString = paste(\"--\", boundary, \"--\", sep = \"\")\n  eStringLoc = which(eString == body)\n  if (length(eStringLoc) == 0) \n    return(body[ (bStringLocs[1] + 1) : (bStringLocs[2] - 1)])\n  \n  n = length(body)\n  if (eStringLoc < n) \n    return( body[ c( (bStringLocs[1] + 1) : (bStringLocs[2] - 1), \n                     ( (eStringLoc + 1) : n )) ] )\n  \n  return( body[ (bStringLocs[1] + 1) : (bStringLocs[2] - 1) ])\n}\n\nhead(sampleSplit[[1]]$body)\n\nmsg = sampleSplit[[3]]$body\nhead(msg)\n\nmsg[ c(1, 3, 26, 27) ]\n\ncleanMsg = tolower(gsub(\"[[:punct:]0-9[:blank:]]+\", \" \", msg))\ncleanMsg[ c(1, 3, 26, 27) ]\n\nlibrary(tm)\nstopWords = stopwords()\ncleanSW = tolower(gsub(\"[[:punct:]0-9[:blank:]]+\", \" \", stopWords))\nSWords = unlist(strsplit(cleanSW, \"[[:blank:]]+\"))\nSWords = SWords[ nchar(SWords) > 1 ]\nstopWords = unique(SWords)\n\nwords = unlist(strsplit(cleanMsg, \"[[:blank:]]+\"))\n\nwords = words[ nchar(words) > 1 ]\n\nwords = words[ !( words %in% stopWords) ]\nhead(words)\n\ncleanText =\n  function(msg)   {\n    tolower(gsub(\"[[:punct:]0-9[:space:][:blank:]]+\", \" \", msg))\n  }\n\nfindMsgWords = \n  function(msg, stopWords) {\n    if(is.null(msg))\n      return(character())\n    \n    words = unique(unlist(strsplit(cleanText(msg), \"[[:blank:]\\t]+\")))\n    \n    # drop empty and 1 letter words\n    words = words[ nchar(words) > 1]\n    words = words[ !( words %in% stopWords) ]\n    invisible(words)\n  }\n\nprocessAllWords = function(dirName, stopWords)\n{\n  # read all files in the directory\n  fileNames = list.files(dirName, full.names = TRUE)\n  # drop files that are not email, i.e., cmds\n  notEmail = grep(\"cmds$\", fileNames)\n  if ( length(notEmail) > 0) fileNames = fileNames[ - notEmail ]\n  \n  messages = lapply(fileNames, readLines, encoding = \"latin1\")\n  \n  # split header and body\n  emailSplit = lapply(messages, splitMessage)\n  # put body and header in own lists\n  bodyList = lapply(emailSplit, function(msg) msg$body)\n  headerList = lapply(emailSplit, function(msg) msg$header)\n  rm(emailSplit)\n  \n  # determine which messages have attachments\n  hasAttach = sapply(headerList, function(header) {\n    CTloc = grep(\"Content-Type\", header)\n    if (length(CTloc) == 0) return(0)\n    multi = grep(\"multi\", tolower(header[CTloc])) \n    if (length(multi) == 0) return(0)\n    multi\n  })\n  \n  hasAttach = which(hasAttach > 0)\n  \n  # find boundary strings for messages with attachments\n  boundaries = sapply(headerList[hasAttach], getBoundary)\n  \n  # drop attachments from message body\n  bodyList[hasAttach] = mapply(dropAttach, bodyList[hasAttach], \n                               boundaries, SIMPLIFY = FALSE)\n  \n  # extract words from body\n  msgWordsList = lapply(bodyList, findMsgWords, stopWords)\n  \n  invisible(msgWordsList)\n}\n\nmsgWordsList = lapply(fullDirNames, processAllWords, \n                      stopWords = stopWords) \n\nnumMsgs = sapply(msgWordsList, length)\nnumMsgs\n\nisSpam = rep(c(FALSE, FALSE, FALSE, TRUE, TRUE), numMsgs)\n\nmsgWordsList = unlist(msgWordsList, recursive = FALSE)\n\nnumEmail = length(isSpam)\nnumSpam = sum(isSpam)\nnumHam = numEmail - numSpam\n\nset.seed(418910)\n\ntestSpamIdx = sample(numSpam, size = floor(numSpam/3))\ntestHamIdx = sample(numHam, size = floor(numHam/3))\n\ntestMsgWords = c((msgWordsList[isSpam])[testSpamIdx],\n                 (msgWordsList[!isSpam])[testHamIdx] )\ntrainMsgWords = c((msgWordsList[isSpam])[ - testSpamIdx], \n                  (msgWordsList[!isSpam])[ - testHamIdx])\n\ntestIsSpam = rep(c(TRUE, FALSE), \n                 c(length(testSpamIdx), length(testHamIdx)))\ntrainIsSpam = rep(c(TRUE, FALSE), \n                  c(numSpam - length(testSpamIdx), \n                    numHam - length(testHamIdx)))\n\nbow = unique(unlist(trainMsgWords))\n\nlength(bow)\n\nspamWordCounts = rep(0, length(bow))\n\nnames(spamWordCounts) = bow\n\ntmp = lapply(trainMsgWords[trainIsSpam], unique)\ntt = table( unlist(tmp) )\nspamWordCounts[ names(tt) ] = tt\n\ncomputeFreqs =\n  function(wordsList, spam, bow = unique(unlist(wordsList)))\n  {\n    # create a matrix for spam, ham, and log odds\n    wordTable = matrix(0.5, nrow = 4, ncol = length(bow), \n                       dimnames = list(c(\"spam\", \"ham\", \n                                         \"presentLogOdds\", \n                                         \"absentLogOdds\"),  bow))\n    \n    # For each spam message, add 1 to counts for words in message\n    counts.spam = table(unlist(lapply(wordsList[spam], unique)))\n    wordTable[\"spam\", names(counts.spam)] = counts.spam + .5\n    \n    # Similarly for ham messages\n    counts.ham = table(unlist(lapply(wordsList[!spam], unique)))  \n    wordTable[\"ham\", names(counts.ham)] = counts.ham + .5  \n    \n    \n    # Find the total number of spam and ham\n    numSpam = sum(spam)\n    numHam = length(spam) - numSpam\n    \n    # Prob(word|spam) and Prob(word | ham)\n    wordTable[\"spam\", ] = wordTable[\"spam\", ]/(numSpam + .5)\n    wordTable[\"ham\", ] = wordTable[\"ham\", ]/(numHam + .5)\n    \n    # log odds\n    wordTable[\"presentLogOdds\", ] = \n      log(wordTable[\"spam\",]) - log(wordTable[\"ham\", ])\n    wordTable[\"absentLogOdds\", ] = \n      log((1 - wordTable[\"spam\", ])) - log((1 -wordTable[\"ham\", ]))\n    \n    invisible(wordTable)\n  }\n\ntrainTable = computeFreqs(trainMsgWords, trainIsSpam)\n\nnewMsg = testMsgWords[[1]]\n\nnewMsg = newMsg[!is.na(match(newMsg, colnames(trainTable)))]\n\npresent = colnames(trainTable) %in% newMsg\n\nsum(trainTable[\"presentLogOdds\", present]) + \n  sum(trainTable[\"absentLogOdds\", !present])\n\nnewMsg = testMsgWords[[ which(!testIsSpam)[1] ]]\nnewMsg = newMsg[!is.na(match(newMsg, colnames(trainTable)))]\npresent = (colnames(trainTable) %in% newMsg)\nsum(trainTable[\"presentLogOdds\", present]) + \n  sum(trainTable[\"absentLogOdds\", !present])\n\ncomputeMsgLLR = function(words, freqTable) \n{\n  # Discards words not in training data.\n  words = words[!is.na(match(words, colnames(freqTable)))]\n  \n  # Find which words are present\n  present = colnames(freqTable) %in% words\n  \n  sum(freqTable[\"presentLogOdds\", present]) +\n    sum(freqTable[\"absentLogOdds\", !present])\n}\n\ntestLLR = sapply(testMsgWords, computeMsgLLR, trainTable)\n\ntapply(testLLR, testIsSpam, summary)\n\npdf(\"SP_Boxplot.pdf\", width = 6, height = 6)\nspamLab = c(\"ham\", \"spam\")[1 + testIsSpam]\nboxplot(testLLR ~ spamLab, ylab = \"Log Likelihood Ratio\",\n        #  main = \"Log Likelihood Ratio for Randomly Chosen Test Messages\",\n        ylim=c(-500, 500))\ndev.off()\n\ntypeIErrorRate = \n  function(tau, llrVals, spam)\n  {\n    classify = llrVals > tau\n    sum(classify & !spam)/sum(!spam)\n  }\n\ntypeIErrorRate(0, testLLR,testIsSpam)\n\ntypeIErrorRate(-20, testLLR,testIsSpam)\n\ntypeIErrorRates = \n  function(llrVals, isSpam) \n  {\n    o = order(llrVals)\n    llrVals =  llrVals[o]\n    isSpam = isSpam[o]\n    \n    idx = which(!isSpam)\n    N = length(idx)\n    list(error = (N:1)/N, values = llrVals[idx])\n  }\n\ntypeIIErrorRates = function(llrVals, isSpam) {\n  \n  o = order(llrVals)\n  llrVals =  llrVals[o]\n  isSpam = isSpam[o]\n  \n  \n  idx = which(isSpam)\n  N = length(idx)\n  list(error = (1:(N))/N, values = llrVals[idx])\n}  \n\nxI = typeIErrorRates(testLLR, testIsSpam)\nxII = typeIIErrorRates(testLLR, testIsSpam)\ntau01 = round(min(xI$values[xI$error <= 0.01]))\nt2 = max(xII$error[ xII$values < tau01 ])\n\npdf(\"LinePlotTypeI+IIErrors.pdf\", width = 8, height = 6)\n\nlibrary(RColorBrewer)\ncols = brewer.pal(9, \"Set1\")[c(3, 4, 5)]\nplot(xII$error ~ xII$values,  type = \"l\", col = cols[1], lwd = 3,\n     xlim = c(-300, 250), ylim = c(0, 1),\n     xlab = \"Log Likelihood Ratio Values\", ylab=\"Error Rate\")\npoints(xI$error ~ xI$values, type = \"l\", col = cols[2], lwd = 3)\nlegend(x = 50, y = 0.4, fill = c(cols[2], cols[1]),\n       legend = c(\"Classify Ham as Spam\", \n                  \"Classify Spam as Ham\"), cex = 0.8,\n       bty = \"n\")\nabline(h=0.01, col =\"grey\", lwd = 3, lty = 2)\ntext(-250, 0.05, pos = 4, \"Type I Error = 0.01\", col = cols[2])\n\nmtext(tau01, side = 1, line = 0.5, at = tau01, col = cols[3])\nsegments(x0 = tau01, y0 = -.50, x1 = tau01, y1 = t2, \n         lwd = 2, col = \"grey\")\ntext(tau01 + 20, 0.05, pos = 4,\n     paste(\"Type II Error = \", round(t2, digits = 2)), \n     col = cols[1])\n\ndev.off()\n\nk = 5\nnumTrain = length(trainMsgWords)\npartK = sample(numTrain)\ntot = k * floor(numTrain/k)\npartK = matrix(partK[1:tot], ncol = k)\n\ntestFoldOdds = NULL\nfor (i in 1:k) {\n  foldIdx = partK[ , i]\n  trainTabFold = computeFreqs(trainMsgWords[-foldIdx], trainIsSpam[-foldIdx])\n  testFoldOdds = c(testFoldOdds, \n                   sapply(trainMsgWords[ foldIdx ], computeMsgLLR, trainTabFold))\n}\n\ntestFoldSpam = NULL\nfor (i in 1:k) {\n  foldIdx = partK[ , i]\n  testFoldSpam = c(testFoldSpam, trainIsSpam[foldIdx])\n}\n\nxFoldI = typeIErrorRates(testFoldOdds, testFoldSpam)\nxFoldII = typeIIErrorRates(testFoldOdds, testFoldSpam)\ntauFoldI = round(min(xFoldI$values[xFoldI$error <= 0.01]))\ntFold2 = xFoldII$error[ xFoldII$values < tauFoldI ]\n\nsmallNums = rep((1/2)^40, 2000000)\nlargeNum = 10000\n\nprint(sum(smallNums), digits = 20)\n\nprint(largeNum + sum(smallNums), digits = 20)\n\nfor (i in 1:length(smallNums)) {\n  largeNum = largeNum + smallNums[i]\n}\nprint(largeNum, digits = 20)\n\nsampleSplit = lapply(sampleEmail, splitMessage)\n\nheader = sampleSplit[[1]]$header\nheader[1:12]\n\nheader[1] = sub(\"^From\", \"Top-From:\", header[1])\nheader[1]\n\nheaderPieces = read.dcf(textConnection(header), all = TRUE)\n\nheaderPieces[, \"Delivered-To\"]\n\n\nheaderVec = unlist(headerPieces)\ndupKeys = sapply(headerPieces, function(x) length(unlist(x)))\nnames(headerVec) = rep(colnames(headerPieces), dupKeys)\n\nheaderVec[ which(names(headerVec) == \"Delivered-To\") ]\n\nlength(headerVec)\n\nlength(unique(names(headerVec)))\n\nprocessHeader = function(header)\n{\n  # modify the first line to create a key:value pair\n  header[1] = sub(\"^From\", \"Top-From:\", header[1])\n  \n  headerMat = read.dcf(textConnection(header), all = TRUE)\n  headerVec = unlist(headerMat)\n  \n  dupKeys = sapply(headerMat, function(x) length(unlist(x)))\n  names(headerVec) = rep(colnames(headerMat), dupKeys)\n  \n  return(headerVec)\n}\n\nheaderList = lapply(sampleSplit, \n                    function(msg) {\n                      processHeader(msg$header)} )\n\ncontentTypes = sapply(headerList, function(header) \n  header[\"Content-Type\"])\nnames(contentTypes) = NULL\ncontentTypes\n\nhasAttach = grep(\"^ *multi\", tolower(contentTypes))\nhasAttach\n\nboundaries = getBoundary(contentTypes[ hasAttach ])\nboundaries\n\nboundary = boundaries[9]\nbody = sampleSplit[[15]]$body\n\nbString = paste(\"--\", boundary, sep = \"\")\nbStringLocs = which(bString == body)\nbStringLocs\n\neString = paste(\"--\", boundary, \"--\", sep = \"\")\neStringLoc = which(eString == body)\neStringLoc\n\ndiff(c(bStringLocs[-1], eStringLoc))\n\n### This code has mistakes in it - and we fix them later!\nprocessAttach = function(body, contentType){\n  \n  boundary = getBoundary(contentType)\n  \n  bString = paste(\"--\", boundary, \"$\", sep = \"\")\n  bStringLocs = grep(bString, body)\n  \n  eString = paste(\"--\", boundary, \"--$\", sep = \"\")\n  eStringLoc = grep(eString, body)\n  \n  n = length(body)\n  \n  if (length(eStringLoc) == 0) eStringLoc = n + 1\n  if (length(bStringLocs) == 1) attachLocs = NULL\n  else attachLocs = c(bStringLocs[-1],  eStringLoc)\n  \n  msg = body[ (bStringLocs[1] + 1) : min(n, (bStringLocs[2] - 1), \n                                         na.rm = TRUE)]\n  \n  if ( eStringLoc < n )\n    msg = c(msg, body[ (eStringLoc + 1) : n ])\n  \n  if ( !is.null(attachLocs) ) {\n    attachLens = diff(attachLocs, lag = 1) \n    attachTypes = mapply(function(begL, endL) {\n      contentTypeLoc = grep(\"[Cc]ontent-[Tt]ype\", body[ (begL + 1) : (endL - 1)])\n      contentType = body[ begL + contentTypeLoc]\n      contentType = gsub('\"', \"\", contentType )\n      MIMEType = sub(\" *Content-Type: *([^;]*);?.*\", \"\\\\1\", contentType)\n      return(MIMEType)\n    }, attachLocs[-length(attachLocs)], attachLocs[-1])\n  }\n  \n  if (is.null(attachLocs)) return(list(body = msg, attachInfo = NULL) )\n  else return(list(body = msg, \n                   attachDF = data.frame(aLen = attachLens, \n                                         aType = attachTypes,\n                                         stringsAsFactors = FALSE)))                                \n}\n\nbodyList = lapply(sampleSplit, function(msg) msg$body)\nattList = mapply(processAttach, bodyList[hasAttach], \n                 contentTypes[hasAttach], \n                 SIMPLIFY = FALSE)\n\nlens = sapply(attList, function(processedA) \n  processedA$attachDF$aLen)\nhead(lens)\n\nattList[[2]]$attachDF\n\nbody = bodyList[hasAttach][[2]]\nlength(body)\n\nbody[35:45]\n\nprocessAttach = function(body, contentType){\n  \n  n = length(body)\n  boundary = getBoundary(contentType)\n  \n  bString = paste(\"--\", boundary, sep = \"\")\n  bStringLocs = which(bString == body)\n  eString = paste(\"--\", boundary, \"--\", sep = \"\")\n  eStringLoc = which(eString == body)\n  \n  if (length(eStringLoc) == 0) eStringLoc = n\n  if (length(bStringLocs) <= 1) {\n    attachLocs = NULL\n    msgLastLine = n\n    if (length(bStringLocs) == 0) bStringLocs = 0\n  } else {\n    attachLocs = c(bStringLocs[ -1 ],  eStringLoc)\n    msgLastLine = bStringLocs[2] - 1\n  }\n  \n  msg = body[ (bStringLocs[1] + 1) : msgLastLine] \n  if ( eStringLoc < n )\n    msg = c(msg, body[ (eStringLoc + 1) : n ])\n  \n  if ( !is.null(attachLocs) ) {\n    attachLens = diff(attachLocs, lag = 1) \n    attachTypes = mapply(function(begL, endL) {\n      CTloc = grep(\"^[Cc]ontent-[Tt]ype\", body[ (begL + 1) : (endL - 1)])\n      if ( length(CTloc) == 0 ) {\n        MIMEType = NA\n      } else {\n        CTval = body[ begL + CTloc[1] ]\n        CTval = gsub('\"', \"\", CTval )\n        MIMEType = sub(\" *[Cc]ontent-[Tt]ype: *([^;]*);?.*\", \"\\\\1\", CTval)   \n      }\n      return(MIMEType)\n    }, attachLocs[-length(attachLocs)], attachLocs[-1])\n  }\n  \n  if (is.null(attachLocs)) return(list(body = msg, attachDF = NULL) )\n  return(list(body = msg, \n              attachDF = data.frame(aLen = attachLens, \n                                    aType = unlist(attachTypes),\n                                    stringsAsFactors = FALSE)))                                \n}                       \n\nreadEmail = function(dirName) {\n  # retrieve the names of files in directory\n  fileNames = list.files(dirName, full.names = TRUE)\n  # drop files that are not email\n  notEmail = grep(\"cmds$\", fileNames)\n  if ( length(notEmail) > 0) fileNames = fileNames[ - notEmail ]\n  \n  # read all files in the directory\n  lapply(fileNames, readLines, encoding = \"latin1\")\n}\n\nprocessAllEmail = function(dirName, isSpam = FALSE)\n{\n  # read all files in the directory\n  messages = readEmail(dirName)\n  fileNames = names(messages)\n  n = length(messages)\n  \n  # split header from body\n  eSplit = lapply(messages, splitMessage)\n  rm(messages)\n  \n  # process header as named character vector\n  headerList = lapply(eSplit, function(msg) \n    processHeader(msg$header))\n  \n  # extract content-type key\n  contentTypes = sapply(headerList, function(header) \n    header[\"Content-Type\"])\n  \n  # extract the body\n  bodyList = lapply(eSplit, function(msg) msg$body)\n  rm(eSplit)\n  \n  # which email have attachments\n  hasAttach = grep(\"^ *multi\", tolower(contentTypes))\n  \n  # get summary stats for attachments and the shorter body\n  attList = mapply(processAttach, bodyList[hasAttach], \n                   contentTypes[hasAttach], SIMPLIFY = FALSE)\n  \n  bodyList[hasAttach] = lapply(attList, function(attEl) \n    attEl$body)\n  \n  attachInfo = vector(\"list\", length = n )\n  attachInfo[ hasAttach ] = lapply(attList, \n                                   function(attEl) attEl$attachDF)\n  \n  # prepare return structure\n  emailList = mapply(function(header, body, attach, isSpam) {\n    list(isSpam = isSpam, header = header, \n         body = body, attach = attach)\n  },\n  headerList, bodyList, attachInfo, \n  rep(isSpam, n), SIMPLIFY = FALSE )\n  names(emailList) = fileNames\n  \n  invisible(emailList)\n}\n\nemailStruct = mapply(processAllEmail, fullDirNames,\n                     isSpam = rep( c(FALSE, TRUE), 3:2))      \nemailStruct = unlist(emailStruct, recursive = FALSE)\n\nsampleStruct = emailStruct[ indx ]\n\nsave(emailStruct, file=\"emailXX.rda\")\n\nheader = sampleStruct[[1]]$header\nsubject = header[\"Subject\"]\nels = strsplit(subject, \"\")\nall(els %in% LETTERS)\n\ntestSubject = c(\"DEAR MADAME\", \"WINNER!\", \"\")\n\nels = strsplit(testSubject, \"\")\nsapply(els, function(subject) all(subject %in% LETTERS))\n\n\ngsub(\"[[:punct:] ]\", \"\", testSubject)\n\ngsub(\"[^[:alpha:]]\", \"\", testSubject)\n\nisYelling = function(msg) {\n  if ( \"Subject\" %in% names(msg$header) ) {\n    el = gsub(\"[^[:alpha:]]\", \"\", msg$header[\"Subject\"])\n    if (nchar(el) > 0) \n      nchar(gsub(\"[A-Z]\", \"\", el)) < 1\n    else \n      FALSE\n  } else \n    NA\n}\n\nperCaps =\n  function(msg)\n  {\n    body = paste(msg$body, collapse = \"\")\n    \n    # Return NA if the body of the message is \"empty\"\n    if(length(body) == 0 || nchar(body) == 0) return(NA)\n    \n    # Eliminate non-alpha characters\n    body = gsub(\"[^[:alpha:]]\", \"\", body)\n    capText = gsub(\"[^A-Z]\", \"\", body)\n    100 * nchar(capText)/nchar(body)\n  }\n\nsapply(sampleStruct, perCaps)\n\nfuncList = list( \n  isRe = function(msg) {\n    \"Subject\" %in% names(msg$header) &&\n      length(grep(\"^[ \\t]*Re:\", msg$header[[\"Subject\"]])) > 0\n  },\n  numLines = function(msg) \n    length(msg$body),\n  isYelling = function(msg) {\n    if ( \"Subject\" %in% names(msg$header) ) {\n      el = gsub(\"[^[:alpha:]]\", \"\", msg$header[\"Subject\"])\n      if (nchar(el) > 0) \n        nchar(gsub(\"[A-Z]\", \"\", el)) < 1\n      else \n        FALSE\n    }\n    else NA\n  },\n  perCaps = function(msg) {\n    body = paste(msg$body, collapse = \"\")\n    \n    # Return NA if the body of the message is \"empty\"\n    if(length(body) == 0 || nchar(body) == 0) return(NA)\n    \n    # Eliminate non-alpha characters\n    body = gsub(\"[^[:alpha:]]\", \"\", body)\n    capText = gsub(\"[^A-Z]\", \"\", body)\n    100 * nchar(capText)/nchar(body)\n  }\n)\n\nlapply(funcList, function(func) \n  sapply(sampleStruct, function(msg) func(msg)))\n\ncreateDerivedDF =\n  function(email = emailStruct, operations = funcList, \n           verbose = FALSE)\n  {\n    els = lapply(names(operations),\n                 function(id) {\n                   if(verbose) print(id)\n                   e = operations[[id]]\n                   v = if(is.function(e)) \n                     sapply(email, e)\n                   else \n                     sapply(email, function(msg) eval(e))\n                   v\n                 })\n    \n    df = as.data.frame(els)\n    names(df) = names(operations)\n    invisible(df)\n  }\n\nsampleDF = createDerivedDF(sampleStruct)\nhead(sampleDF)\n\nfuncList = list(\n  isSpam =\n    expression(msg$isSpam)\n  ,\n  isRe =\n    function(msg) {\n      # Can have a Fwd: Re:  ... but we are not looking for this here.\n      # We may want to look at In-Reply-To field.\n      \"Subject\" %in% names(msg$header) && \n        length(grep(\"^[ \\t]*Re:\", msg$header[[\"Subject\"]])) > 0\n    }\n  ,\n  numLines =\n    function(msg) length(msg$body)\n  ,\n  bodyCharCt =\n    function(msg)\n      sum(nchar(msg$body))\n  ,\n  underscore =\n    function(msg) {\n      if(!\"Reply-To\" %in% names(msg$header))\n        return(FALSE)\n      \n      txt <- msg$header[[\"Reply-To\"]]\n      length(grep(\"_\", txt)) > 0  && \n        length(grep(\"[0-9A-Za-z]+\", txt)) > 0\n    }\n  ,\n  subExcCt = \n    function(msg) {\n      x = msg$header[\"Subject\"]\n      if(length(x) == 0 || sum(nchar(x)) == 0 || is.na(x))\n        return(NA)\n      \n      sum(nchar(gsub(\"[^!]\",\"\", x)))\n    }\n  ,\n  subQuesCt =\n    function(msg) {\n      x = msg$header[\"Subject\"]\n      if(length(x) == 0 || sum(nchar(x)) == 0 || is.na(x))\n        return(NA)\n      \n      sum(nchar(gsub(\"[^?]\",\"\", x)))\n    }\n  ,\n  numAtt = \n    function(msg) {\n      if (is.null(msg$attach)) return(0)\n      else nrow(msg$attach)\n    }\n  \n  ,\n  priority =\n    function(msg) {\n      ans <- FALSE\n      # Look for names X-Priority, Priority, X-Msmail-Priority\n      # Look for high any where in the value\n      ind = grep(\"priority\", tolower(names(msg$header)))\n      if (length(ind) > 0)  {\n        ans <- length(grep(\"high\", tolower(msg$header[ind]))) >0\n      }\n      ans\n    }\n  ,\n  numRec =\n    function(msg) {\n      # unique or not.\n      els = getMessageRecipients(msg$header)\n      \n      if(length(els) == 0)\n        return(NA)\n      \n      # Split each line by \",\"  and in each of these elements, look for\n      # the @ sign. This handles\n      tmp = sapply(strsplit(els, \",\"), function(x) grep(\"@\", x))\n      sum(sapply(tmp, length))\n    }\n  ,\n  perCaps =\n    function(msg)\n    {\n      body = paste(msg$body, collapse = \"\")\n      \n      # Return NA if the body of the message is \"empty\"\n      if(length(body) == 0 || nchar(body) == 0) return(NA)\n      \n      # Eliminate non-alpha characters and empty lines \n      body = gsub(\"[^[:alpha:]]\", \"\", body)\n      els = unlist(strsplit(body, \"\"))\n      ctCap = sum(els %in% LETTERS)\n      100 * ctCap / length(els)\n    }\n  ,\n  isInReplyTo =\n    function(msg)\n    {\n      \"In-Reply-To\" %in% names(msg$header)\n    }\n  ,\n  sortedRec =\n    function(msg)\n    {\n      ids = getMessageRecipients(msg$header)\n      all(sort(ids) == ids)\n    }\n  ,\n  subPunc =\n    function(msg)\n    {\n      if(\"Subject\" %in% names(msg$header)) {\n        el = gsub(\"['/.:@-]\", \"\", msg$header[\"Subject\"])\n        length(grep(\"[A-Za-z][[:punct:]]+[A-Za-z]\", el)) > 0\n      }\n      else\n        FALSE\n    },\n  hour =\n    function(msg)\n    {\n      date = msg$header[\"Date\"]\n      if ( is.null(date) ) return(NA)\n      # Need to handle that there may be only one digit in the hour\n      locate = regexpr(\"[0-2]?[0-9]:[0-5][0-9]:[0-5][0-9]\", date)\n      \n      if (locate < 0)\n        locate = regexpr(\"[0-2]?[0-9]:[0-5][0-9]\", date)\n      if (locate < 0) return(NA)\n      \n      hour = substring(date, locate, locate+1)\n      hour = as.numeric(gsub(\":\", \"\", hour))\n      \n      locate = regexpr(\"PM\", date)\n      if (locate > 0) hour = hour + 12\n      \n      locate = regexpr(\"[+-][0-2][0-9]00\", date)\n      if (locate < 0) offset = 0\n      else offset = as.numeric(substring(date, locate, locate + 2))\n      (hour - offset) %% 24\n    }\n  ,\n  multipartText =\n    function(msg)\n    {\n      if (is.null(msg$attach)) return(FALSE)\n      numAtt = nrow(msg$attach)\n      \n      types = \n        length(grep(\"(html|plain|text)\", msg$attach$aType)) > (numAtt/2)\n    }\n  ,\n  hasImages =\n    function(msg)\n    {\n      if (is.null(msg$attach)) return(FALSE)\n      \n      length(grep(\"^ *image\", tolower(msg$attach$aType))) > 0\n    }\n  ,\n  isPGPsigned =\n    function(msg)\n    {\n      if (is.null(msg$attach)) return(FALSE)\n      \n      length(grep(\"pgp\", tolower(msg$attach$aType))) > 0\n    },\n  perHTML =\n    function(msg)\n    {\n      if(! (\"Content-Type\" %in% names(msg$header))) return(0)\n      \n      el = tolower(msg$header[\"Content-Type\"]) \n      if (length(grep(\"html\", el)) == 0) return(0)\n      \n      els = gsub(\"[[:space:]]\", \"\", msg$body)\n      totchar = sum(nchar(els))\n      totplain = sum(nchar(gsub(\"<[^<]+>\", \"\", els )))\n      100 * (totchar - totplain)/totchar\n    },\n  subSpamWords =\n    function(msg)\n    {\n      if(\"Subject\" %in% names(msg$header))\n        length(grep(paste(SpamCheckWords, collapse = \"|\"), \n                    tolower(msg$header[\"Subject\"]))) > 0\n      else\n        NA\n    }\n  ,\n  subBlanks =\n    function(msg)\n    {\n      if(\"Subject\" %in% names(msg$header)) {\n        x = msg$header[\"Subject\"]\n        # should we count blank subject line as 0 or 1 or NA?\n        if (nchar(x) == 1) return(0)\n        else 100 *(1 - (nchar(gsub(\"[[:blank:]]\", \"\", x))/nchar(x)))\n      } else NA\n    }\n  ,\n  noHost =\n    function(msg)\n    {\n      # Or use partial matching.\n      idx = pmatch(\"Message-\", names(msg$header))\n      \n      if(is.na(idx)) return(NA)\n      \n      tmp = msg$header[idx]\n      return(length(grep(\".*@[^[:space:]]+\", tmp)) ==  0)\n    }\n  ,\n  numEnd =\n    function(msg)\n    {\n      # If we just do a grep(\"[0-9]@\",  )\n      # we get matches on messages that have a From something like\n      # \" \\\"marty66@aol.com\\\" <synjan@ecis.com>\"\n      # and the marty66 is the \"user's name\" not the login\n      # So we can be more precise if we want.\n      x = names(msg$header)\n      if ( !( \"From\" %in% x) ) return(NA)\n      login = gsub(\"^.*<\", \"\", msg$header[\"From\"])\n      if ( is.null(login) ) \n        login = gsub(\"^.*<\", \"\", msg$header[\"X-From\"])\n      if ( is.null(login) ) return(NA)\n      login = strsplit(login, \"@\")[[1]][1]\n      length(grep(\"[0-9]+$\", login)) > 0\n    },\n  isYelling =\n    function(msg)\n    {\n      if ( \"Subject\" %in% names(msg$header) ) {\n        el = gsub(\"[^[:alpha:]]\", \"\", msg$header[\"Subject\"])\n        if (nchar(el) > 0) nchar(gsub(\"[A-Z]\", \"\", el)) < 1\n        else FALSE\n      }\n      else\n        NA\n    },\n  forwards =\n    function(msg)\n    {\n      x = msg$body\n      if(length(x) == 0 || sum(nchar(x)) == 0)\n        return(NA)\n      \n      ans = length(grep(\"^[[:space:]]*>\", x))\n      100 * ans / length(x)\n    },\n  isOrigMsg =\n    function(msg)\n    {\n      x = msg$body\n      if(length(x) == 0) return(NA)\n      \n      length(grep(\"^[^[:alpha:]]*original[^[:alpha:]]+message[^[:alpha:]]*$\", \n                  tolower(x) ) ) > 0\n    },\n  isDear =\n    function(msg)\n    {\n      x = msg$body\n      if(length(x) == 0) return(NA)\n      \n      length(grep(\"^[[:blank:]]*dear +(sir|madam)\\\\>\", \n                  tolower(x))) > 0\n    },\n  isWrote =\n    function(msg)\n    {\n      x = msg$body\n      if(length(x) == 0) return(NA)\n      \n      length(grep(\"(wrote|schrieb|ecrit|escribe):\", tolower(x) )) > 0\n    },\n  avgWordLen =\n    function(msg)\n    {\n      txt = paste(msg$body, collapse = \" \")\n      if(length(txt) == 0 || sum(nchar(txt)) == 0) return(0)\n      \n      txt = gsub(\"[^[:alpha:]]\", \" \", txt)\n      words = unlist(strsplit(txt, \"[[:blank:]]+\"))\n      wordLens = nchar(words)\n      mean(wordLens[ wordLens > 0 ])\n    }\n  ,\n  numDlr =\n    function(msg)\n    {\n      x = paste(msg$body, collapse = \"\")\n      if(length(x) == 0 || sum(nchar(x)) == 0)\n        return(NA)\n      \n      nchar(gsub(\"[^$]\",\"\", x))\n    }\n)\n\n\nSpamCheckWords =\n  c(\"viagra\", \"pounds\", \"free\", \"weight\", \"guarantee\", \"million\", \n    \"dollars\", \"credit\", \"risk\", \"prescription\", \"generic\", \"drug\",\n    \"financial\", \"save\", \"dollar\", \"erotic\", \"million\", \"barrister\",\n    \"beneficiary\", \"easy\", \n    \"money back\", \"money\", \"credit card\")\n\n\ngetMessageRecipients =\n  function(header)\n  {\n    c(if(\"To\" %in% names(header))  header[[\"To\"]] else character(0),\n      if(\"Cc\" %in% names(header))  header[[\"Cc\"]] else character(0),\n      if(\"Bcc\" %in% names(header)) header[[\"Bcc\"]] else character(0)\n    )\n  }\n\nemailDF = createDerivedDF(emailStruct)\ndim(emailDF)\n#save(emailDF, file = \"spamAssassinDerivedDF.rda\")\n\nload(\"Data/spamAssassinDerivedDF.rda\")\ndim(emailDF)\n\nperCaps2 =\n  function(msg)\n  {\n    body = paste(msg$body, collapse = \"\")\n    \n    # Return NA if the body of the message is \"empty\"\n    if(length(body) == 0 || nchar(body) == 0) return(NA)\n    \n    # Eliminate non-alpha characters and empty lines \n    body = gsub(\"[^[:alpha:]]\", \"\", body)\n    els = unlist(strsplit(body, \"\"))\n    ctCap = sum(els %in% LETTERS)\n    100 * ctCap / length(els)\n  }\n\npC = sapply(emailStruct, perCaps)\npC2 = sapply(emailStruct, perCaps2)\nidentical(pC, pC2)\n\nindNA = which(is.na(emailDF$subExcCt))\n\nindNoSubject = which(sapply(emailStruct, \n                            function(msg) \n                              !(\"Subject\" %in% names(msg$header))))\n\nall(indNA == indNoSubject)\n\nall(emailDF$bodyCharCt > emailDF$numLines)\n\n\nx.at = c(1,10,100,1000,10000,100000)\ny.at = c(1, 5, 10, 50, 100, 500, 5000)\nnL = 1 + emailDF$numLines\nnC = 1 + emailDF$bodyCharCt\npdf(\"ScatterPlotNumLinesNumChars.pdf\", width = 6, height = 4.5)\nplot(nL ~ nC, log = \"xy\", pch=\".\", xlim=c(1,100000), axes = FALSE,\n     xlab = \"Number of Characters\", ylab = \"Number of Lines\")\nbox() \naxis(1, at = x.at, labels = formatC(x.at, digits = 0, format=\"d\"))\naxis(2, at = y.at, labels = formatC(y.at, digits = 0, format=\"d\")) \nabline(a=0, b=1, col=\"red\", lwd = 2)\ndev.off()\n\npdf(\"SPAM_boxplotsPercentCaps.pdf\", width = 5, height = 5)\n\npercent = emailDF$perCaps\nisSpamLabs = factor(emailDF$isSpam, labels = c(\"ham\", \"spam\"))\nboxplot(log(1 + percent) ~ isSpamLabs,\n        ylab = \"Percent Capitals (log)\")\n\ndev.off()\n\nlogPerCapsSpam = log(1 + emailDF$perCaps[ emailDF$isSpam ])\nlogPerCapsHam = log(1 + emailDF$perCaps[ !emailDF$isSpam ])\n\nqqplot(logPerCapsSpam, logPerCapsHam, \n       xlab = \"Regular Email\", ylab = \"Spam Email\", \n       main = \"Percentage of Capital Letters (log scale)\",\n       pch = 19, cex = 0.3)\n\npdf(\"SPAM_scatterplotPercentCapsTotChars.pdf\", width = 8, height = 6)\n\ncolI = c(\"#4DAF4A80\", \"#984EA380\")\nlogBodyCharCt = log(1 + emailDF$bodyCharCt)\nlogPerCaps = log(1 + emailDF$perCaps)\nplot(logPerCaps ~ logBodyCharCt, xlab = \"Total Characters (log)\",\n     ylab = \"Percent Capitals (log)\",\n     col = colI[1 + emailDF$isSpam],\n     xlim = c(2,12), pch = 19, cex = 0.5)\n\ndev.off()\n\ntable(emailDF$numAtt, isSpamLabs)\n\npdf(\"SPAM_mosaicPlots.pdf\", width = 8, height = 4)\n\noldPar = par(mfrow = c(1, 2), mar = c(1,1,1,1))\n\ncolM = c(\"#E41A1C80\", \"#377EB880\")\nisRe = factor(emailDF$isRe, labels = c(\"no Re:\", \"Re:\"))\nmosaicplot(table(isSpamLabs, isRe), main = \"\",\n           xlab = \"\", ylab = \"\", color = colM)\n\nfromNE = factor(emailDF$numEnd, labels = c(\"No #\", \"#\"))\nmosaicplot(table(isSpamLabs, fromNE), color = colM,\n           main = \"\", xlab=\"\", ylab = \"\")\n\npar(oldPar)\n\ndev.off()\n\nlibrary(rpart)\n\nsetupRpart = function(data) {\n  logicalVars = which(sapply(data, is.logical))\n  facVars = lapply(data[ , logicalVars], \n                   function(x) {\n                     x = as.factor(x)\n                     levels(x) = c(\"F\", \"T\")\n                     x\n                   })\n  cbind(facVars, data[ , - logicalVars])\n}\n\nemailDFrp = setupRpart(emailDF)\n\n\nset.seed(418910)\ntestSpamIdx = sample(numSpam, size = floor(numSpam/3))\ntestHamIdx = sample(numHam, size = floor(numHam/3))\n\ntestDF = \n  rbind( emailDFrp[ emailDFrp$isSpam == \"T\", ][testSpamIdx, ],\n         emailDFrp[emailDFrp$isSpam == \"F\", ][testHamIdx, ] )\ntrainDF =\n  rbind( emailDFrp[emailDFrp$isSpam == \"T\", ][-testSpamIdx, ], \n         emailDFrp[emailDFrp$isSpam == \"F\", ][-testHamIdx, ])\n\nrpartFit = rpart(isSpam ~ ., data = trainDF, method = \"class\")\n\nlibrary(rpart.plot)\nprp(rpartFit, extra = 1)\n\nlibrary(rpart.plot)\npdf(\"SPAM_rpartTree.pdf\", width = 7, height = 7)\n\nprp(rpartFit, extra = 1)\ndev.off()\n\npredictions = predict(rpartFit, \n                      newdata = testDF[, names(testDF) != \"isSpam\"],\n                      type = \"class\")\n\npredsForHam = predictions[ testDF$isSpam == \"F\" ]\nsummary(predsForHam)\n\nsum(predsForHam == \"T\") / length(predsForHam)\n\npredsForSpam = predictions[ testDF$isSpam == \"T\" ]\nsum(predsForSpam == \"F\") / length(predsForSpam)\n\ncomplexityVals = c(seq(0.00001, 0.0001, length=19),\n                   seq(0.0001, 0.001, length=19), \n                   seq(0.001, 0.005, length=9),\n                   seq(0.005, 0.01, length=9))\n\nfits = lapply(complexityVals, function(x) {\n  rpartObj = rpart(isSpam ~ ., data = trainDF,\n                   method=\"class\", \n                   control = rpart.control(cp=x) )\n  \n  predict(rpartObj, \n          newdata = testDF[ , names(testDF) != \"isSpam\"],\n          type = \"class\")\n})\n\nspam = testDF$isSpam == \"T\"\nnumSpam = sum(spam)\nnumHam = sum(!spam)\nerrs = sapply(fits, function(preds) {\n  typeI = sum(preds[ !spam ] == \"T\") / numHam\n  typeII = sum(preds[ spam ] == \"F\") / numSpam\n  c(typeI = typeI, typeII = typeII)\n})\n\npdf(\"SPAM_rpartTypeIandII.pdf\", width = 8, height = 7)\nlibrary(RColorBrewer)\ncols = brewer.pal(9, \"Set1\")[c(3, 4, 5)]\nplot(errs[1,] ~ complexityVals, type=\"l\", col=cols[2], \n     lwd = 2, ylim = c(0,0.2), xlim = c(0,0.005), \n     ylab=\"Error\", xlab=\"complexity parameter values\")\npoints(errs[2,] ~ complexityVals, type=\"l\", col=cols[1], lwd = 2)\n\ntext(x =c(0.003, 0.0035), y = c(0.12, 0.05), \n     labels=c(\"Type II Error\", \"Type I Error\"))\n\nminI = which(errs[1,] == min(errs[1,]))[1]\nabline(v = complexityVals[minI], col =\"grey\", lty =3, lwd=2)\n\ntext(0.0007, errs[1, minI]+0.01, \n     formatC(errs[1, minI], digits = 2))\ntext(0.0007, errs[2, minI]+0.01, \n     formatC(errs[2, minI], digits = 3))\n\ndev.off()",
    "created" : 1538887596182.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "3570715479",
    "id" : "38C01B54",
    "lastKnownWriteTime" : 1538926975,
    "last_content_update" : 1538926975809,
    "path" : "~/Desktop/SMU/QTW/Week5/spamfinder.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled5"
    },
    "relative_order" : 14,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}