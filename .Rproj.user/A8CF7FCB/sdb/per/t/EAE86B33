{
    "collab_server" : "",
    "contents" : "#http://www.sthda.com/english/articles/35-statistical-machine-learning-essentials/141-cart-model-decision-tree-essentials\n\n#load(\"/Users/ramya/Desktop/CS10QTW.RData\") \n\n#Install RSpamData package that has all the emailfolders but this package is not availabel for version 3.5.0\nspamPath = \"/Users/rsimham/Desktop/SMU/QTW/Week5/SpamAssassinMessages\"\n\nlist.dirs(spamPath, full.names = FALSE)\n#Results for the above are the below folders:\n#[1] \"\"           \"easy_ham\"   \"easy_ham_2\" \"hard_ham\"   \"spam\"       \"spam_2\"\n\n#list.dirs(path, full.names = FALSE)\n\n#We can observe fromt the folders listed that the ham messages have been....\n#organized into those that are easy or difficult to detect\n\n#Look at some of the files in the easy_ham folder\nhead(list.files(path = paste(spamPath, \"easy_ham\",\n                             sep = .Platform$file.sep)))\n\n#We check that the names of the messages in the spam directories look the same as those in the ham directories with\nhead(list.files(path = paste(spamPath, \"spam_2\",\n                             sep = .Platform$file.sep)))\n#How many files are there all together?\ndirNames = list.files(path = spamPath)\nlength(list.files(paste(spamPath, dirNames,\n                        sep = .Platform$file.sep)))\n#Result 9353\n\n#There are over 9000 messages in the 5 directories combined. \n#These are not equally divided between the 5 directories, i.e.,\nsapply(paste(spamPath,dirNames,\n             sep = .Platform$file.sep),\n       function(dir) length(list.files(dir)) )\n#Result: /Users/ramya/Documents/SMU/QTW/Week6/SpamAssassinMessages/easy_ham \n#5052 \n#/Users/ramya/Documents/SMU/QTW/Week6/SpamAssassinMessages/easy_ham_2 \n#1401 \n#/Users/ramya/Documents/SMU/QTW/Week6/SpamAssassinMessages/hard_ham \n#501 \n#/Users/ramya/Documents/SMU/QTW/Week6/SpamAssassinMessages/spam \n#1001 \n#/Users/ramya/Documents/SMU/QTW/Week6/SpamAssassinMessages/spam_2 \n#1398 \n\n#Construct fullname for these directories \nfullDirNames = paste(spamPath, dirNames,\n                     sep = .Platform$file.sep)\n#Obtain full names of the files within the first directiry \nfileNames = list.files(fullDirNames[1], full.names = TRUE)\nfileNames[1]\n\n#Read the first message in easy_ham\nmsg = readLines(fileNames[1])\nhead(msg)\n\n#We have chosen, by manual inspection, 15 ham message files from the first directory...\n#that exhibit different characteristics of email. We read them into R as follows:\n\nindx = c(1:5, 15, 27, 68, 69, 329, 404, 427, 516, 852, 971)\nfn = list.files(fullDirNames[1], full.names = TRUE)[indx]\nsampleEmail = sapply(fn, readLines)\n\n\n\n############################\nmsg = sampleEmail[[1]]\nwhich(msg == \"\")[1]\n\nmatch(\"\", msg)\n\nsplitPoint = match(\"\", msg)\n\nmsg[ (splitPoint - 2):(splitPoint + 6) ]\n\nheader = msg[1:(splitPoint-1)]\nbody = msg[ -(1:splitPoint) ]\n\nsplitMessage = function(msg) {\n  splitPoint = match(\"\", msg)\n  header = msg[1:(splitPoint-1)]\n  body = msg[ -(1:splitPoint) ]\n  return(list(header = header, body = body))\n}\n\nsampleSplit = lapply(sampleEmail, splitMessage)\n\nheader = sampleSplit[[1]]$header\ngrep(\"Content-Type\", header)\n\ngrep(\"multi\", tolower(header[46]))\n\nheader[46]\n\nheaderList = lapply(sampleSplit, function(msg) msg$header)\nCTloc = sapply(headerList, grep, pattern = \"Content-Type\")\nCTloc\n\nsapply(headerList, function(header) {\n  CTloc = grep(\"Content-Type\", header)\n  if (length(CTloc) == 0) return(NA)\n  CTloc\n})\n\nhasAttach = sapply(headerList, function(header) {\n  CTloc = grep(\"Content-Type\", header)\n  if (length(CTloc) == 0) return(FALSE)\n  grepl(\"multi\", tolower(header[CTloc])) \n})\n\nhasAttach\n\nheader = sampleSplit[[6]]$header\nboundaryIdx = grep(\"boundary=\", header)\nheader[boundaryIdx]\n\nsub(\".*boundary=\\\"(.*)\\\";.*\", \"\\\\1\", header[boundaryIdx])\n\nheader2 = headerList[[9]]\nboundaryIdx2 = grep(\"boundary=\", header2)\nheader2[boundaryIdx2]\n\n#Boundary\nsub('.*boundary=\"(.*)\";.*', \"\\\\1\", header2[boundaryIdx2])\n\nboundary2 = gsub('\"', \"\", header2[boundaryIdx2])\n\nsub(\".*boundary= *(.*);?.*\", \"\\\\1\", boundary2)\n\nboundary = gsub('\"', \"\", header[boundaryIdx])\nsub(\".*boundary= *(.*);?.*\", \"\\\\1\", boundary)\n\nsub(\".*boundary= *([^;]*);?.*\", \"\\\\1\", boundary)\n\ngetBoundary = function(header) {\n  boundaryIdx = grep(\"boundary=\", header)\n  boundary = gsub('\"', \"\", header[boundaryIdx])\n  gsub(\".*boundary= *([^;]*);?.*\", \"\\\\1\", boundary)\n}\n\nsampleSplit[[6]]$body\n\nboundary = getBoundary(headerList[[15]]) \nbody = sampleSplit[[15]]$body\n\nbString = paste(\"--\", boundary, sep = \"\")\nbStringLocs = which(bString == body)\nbStringLocs\n\neString = paste(\"--\", boundary, \"--\", sep = \"\")\neStringLoc = which(eString == body)\neStringLoc\n\nmsg = body[ (bStringLocs[1] + 1) : (bStringLocs[2] - 1)]\ntail(msg)\n\nmsg = c(msg, body[ (eStringLoc + 1) : length(body) ])\ntail(msg)\n\n\n###Line 46\ndropAttach = function(body, boundary){\n  \n  bString = paste(\"--\", boundary, sep = \"\")\n  bStringLocs = which(bString == body)\n  \n  if (length(bStringLocs) <= 1) return(body)\n  \n  eString = paste(\"--\", boundary, \"--\", sep = \"\")\n  eStringLoc = which(eString == body)\n  if (length(eStringLoc) == 0) \n    return(body[ (bStringLocs[1] + 1) : (bStringLocs[2] - 1)])\n  \n  n = length(body)\n  if (eStringLoc < n) \n    return( body[ c( (bStringLocs[1] + 1) : (bStringLocs[2] - 1), \n                     ( (eStringLoc + 1) : n )) ] )\n  \n  return( body[ (bStringLocs[1] + 1) : (bStringLocs[2] - 1) ])\n}\n\nhead(sampleSplit[[1]]$body)\n\nmsg = sampleSplit[[3]]$body\nhead(msg)\n\nmsg[ c(1, 3, 26, 27) ]\n\ncleanMsg = tolower(gsub(\"[[:punct:]0-9[:blank:]]+\", \" \", msg))\ncleanMsg[ c(1, 3, 26, 27) ]\n\ninstall.packages(\"tm\", repos=\"http://R-Forge.R-project.org\")\n\ninstall.packages('devtools')\nlibrary(devtools)\n\nslam_url <- \"https://cran.r-project.org/src/contrib/Archive/slam/slam_0.1-37.tar.gz\"\ninstall_url(slam_url)\n\ninstall.packages(\"slam\")\ninstall.packages(\"xml2\")\ninstall.packages(\"tm\")\n\nlibrary(tm)\nstopWords = stopwords()\ncleanSW = tolower(gsub(\"[[:punct:]0-9[:blank:]]+\", \" \", stopWords))\nSWords = unlist(strsplit(cleanSW, \"[[:blank:]]+\"))\nSWords = SWords[ nchar(SWords) > 1 ]\nstopWords = unique(SWords)\n\n\n#Line 47 extract content words\nwords = unlist(strsplit(cleanMsg, \"[[:blank:]]+\"))\n\nwords = words[ nchar(words) > 1 ]\n\nwords = words[ !( words %in% stopWords) ]\nhead(words)\n\ncleanText =\n  function(msg)   {\n    tolower(gsub(\"[[:punct:]0-9[:space:][:blank:]]+\", \" \", msg))\n  }\n\nfindMsgWords = \n  function(msg, stopWords) {\n    if(is.null(msg))\n      return(character())\n    \n    words = unique(unlist(strsplit(cleanText(msg), \"[[:blank:]\\t]+\")))\n    \n    # drop empty and 1 letter words\n    words = words[ nchar(words) > 1]\n    words = words[ !( words %in% stopWords) ]\n    invisible(words)\n  }\n\n## readline error \nlibrary(sys)\nSys.setlocale(\"LC_ALL\", \"C\")\n\n#line 48 process all words\nprocessAllWords = function(dirName, stopWords)\n{\n  # read all files in the directory\n  fileNames = list.files(dirName, full.names = TRUE)\n  # drop files that are not email, i.e., cmds\n  notEmail = grep(\"cmds$\", fileNames)\n  if ( length(notEmail) > 0) fileNames = fileNames[ - notEmail ]\n  \n  #encoding = \"latin1\"\n  messages = lapply(fileNames, readLines, encoding = \"latin1\")\n  \n  # split header and body\n  emailSplit = lapply(messages, splitMessage)\n  # put body and header in own lists\n  bodyList = lapply(emailSplit, function(msg) msg$body)\n  headerList = lapply(emailSplit, function(msg) msg$header)\n  rm(emailSplit)\n  \n  # determine which messages have attachments\n  hasAttach = sapply(headerList, function(header) {\n    CTloc = grep(\"Content-Type\", header)\n    if (length(CTloc) == 0) return(0)\n    multi = grep(\"multi\", tolower(header[CTloc])) \n    if (length(multi) == 0) return(0)\n    multi\n  })\n  \n  hasAttach = which(hasAttach > 0)\n  \n  # find boundary strings for messages with attachments\n  boundaries = sapply(headerList[hasAttach], getBoundary)\n  \n  # drop attachments from message body\n  bodyList[hasAttach] = mapply(dropAttach, bodyList[hasAttach], \n                               boundaries, SIMPLIFY = FALSE)\n  \n  # extract words from body\n  msgWordsList = lapply(bodyList, findMsgWords, stopWords)\n  \n  invisible(msgWordsList)\n}#end of line 48\n\n#LIne 49\nmsgWordsList = lapply(fullDirNames, processAllWords, \n                      stopWords = stopWords) \n\n#Line 50\nnumMsgs = sapply(msgWordsList, length)\nnumMsgs\n\n#Line 51\nisSpam = rep(c(FALSE, FALSE, FALSE, TRUE, TRUE), numMsgs)\n\nmsgWordsList = unlist(msgWordsList, recursive = FALSE)\n\nnumEmail = length(isSpam)\nnumSpam = sum(isSpam)\nnumHam = numEmail - numSpam\n\nset.seed(418910)\n\ntestSpamIdx = sample(numSpam, size = floor(numSpam/3))\ntestHamIdx = sample(numHam, size = floor(numHam/3))\n\ntestMsgWords = c((msgWordsList[isSpam])[testSpamIdx],\n                 (msgWordsList[!isSpam])[testHamIdx] )\ntrainMsgWords = c((msgWordsList[isSpam])[ - testSpamIdx], \n                  (msgWordsList[!isSpam])[ - testHamIdx])\n\ntestIsSpam = rep(c(TRUE, FALSE), \n                 c(length(testSpamIdx), length(testHamIdx)))\ntrainIsSpam = rep(c(TRUE, FALSE), \n                  c(numSpam - length(testSpamIdx), \n                    numHam - length(testHamIdx)))\n\nbow = unique(unlist(trainMsgWords))\n\nlength(bow)\n\nspamWordCounts = rep(0, length(bow))\n\nnames(spamWordCounts) = bow\n\ntmp = lapply(trainMsgWords[trainIsSpam], unique)\ntt = table( unlist(tmp) )\nspamWordCounts[ names(tt) ] = tt\n\nspamWordCounts\n\n#Line 52\ncomputeFreqs =\n  function(wordsList, spam, bow = unique(unlist(wordsList)))\n  {\n    # create a matrix for spam, ham, and log odds\n    wordTable = matrix(0.5, nrow = 4, ncol = length(bow), \n                       dimnames = list(c(\"spam\", \"ham\", \n                                         \"presentLogOdds\", \n                                         \"absentLogOdds\"),  bow))\n    \n    # For each spam message, add 1 to counts for words in message\n    counts.spam = table(unlist(lapply(wordsList[spam], unique)))\n    wordTable[\"spam\", names(counts.spam)] = counts.spam + .5\n    \n    # Similarly for ham messages\n    counts.ham = table(unlist(lapply(wordsList[!spam], unique)))  \n    wordTable[\"ham\", names(counts.ham)] = counts.ham + .5  \n    \n    \n    # Find the total number of spam and ham\n    numSpam = sum(spam)\n    numHam = length(spam) - numSpam\n    \n    # Prob(word|spam) and Prob(word | ham)\n    wordTable[\"spam\", ] = wordTable[\"spam\", ]/(numSpam + .5)\n    wordTable[\"ham\", ] = wordTable[\"ham\", ]/(numHam + .5)\n    \n    # log odds\n    wordTable[\"presentLogOdds\", ] = \n      log(wordTable[\"spam\",]) - log(wordTable[\"ham\", ])\n    wordTable[\"absentLogOdds\", ] = \n      log((1 - wordTable[\"spam\", ])) - log((1 -wordTable[\"ham\", ]))\n    \n    invisible(wordTable)\n  }\n\n#Line 53\ntrainTable = computeFreqs(trainMsgWords, trainIsSpam)\n\nnewMsg = testMsgWords[[1]]\n\nnewMsg = newMsg[!is.na(match(newMsg, colnames(trainTable)))]\n\npresent = colnames(trainTable) %in% newMsg\n\nsum(trainTable[\"presentLogOdds\", present]) + \n  sum(trainTable[\"absentLogOdds\", !present])\n\nnewMsg = testMsgWords[[ which(!testIsSpam)[1] ]]\nnewMsg = newMsg[!is.na(match(newMsg, colnames(trainTable)))]\npresent = (colnames(trainTable) %in% newMsg)\nsum(trainTable[\"presentLogOdds\", present]) + \n  sum(trainTable[\"absentLogOdds\", !present])\n\ncomputeMsgLLR = function(words, freqTable) \n{\n  # Discards words not in training data.\n  words = words[!is.na(match(words, colnames(freqTable)))]\n  \n  # Find which words are present\n  present = colnames(freqTable) %in% words\n  \n  sum(freqTable[\"presentLogOdds\", present]) +\n    sum(freqTable[\"absentLogOdds\", !present])\n}\n\ntestLLR = sapply(testMsgWords, computeMsgLLR, trainTable)\n\ntapply(testLLR, testIsSpam, summary)\n\n\n#Line 54\n#pdf(\"SP_Boxplot.pdf\", width = 6, height = 6)\nspamLab = c(\"ham\", \"spam\")[1 + testIsSpam]\nboxplot(testLLR ~ spamLab, ylab = \"Log Likelihood Ratio\",\n        #  main = \"Log Likelihood Ratio for Randomly Chosen Test Messages\",\n        ylim=c(-500, 500))\n#dev.off()\n\n#Line 55\ntypeIErrorRate = \n  function(tau, llrVals, spam)\n  {\n    classify = llrVals > tau\n    sum(classify & !spam)/sum(!spam)\n  }\n\ntypeIErrorRate(0, testLLR,testIsSpam)\n\ntypeIErrorRate(-20, testLLR,testIsSpam)\n\ntypeIErrorRates = \n  function(llrVals, isSpam) \n  {\n    o = order(llrVals)\n    llrVals =  llrVals[o]\n    isSpam = isSpam[o]\n    \n    idx = which(!isSpam)\n    N = length(idx)\n    list(error = (N:1)/N, values = llrVals[idx])\n  }\n\n#Line 56\ntypeIIErrorRates = function(llrVals, isSpam) {\n  \n  o = order(llrVals)\n  llrVals =  llrVals[o]\n  isSpam = isSpam[o]\n  \n  \n  idx = which(isSpam)\n  N = length(idx)\n  list(error = (1:(N))/N, values = llrVals[idx])\n}  \n\nxI = typeIErrorRates(testLLR, testIsSpam)\nxII = typeIIErrorRates(testLLR, testIsSpam)\ntau01 = round(min(xI$values[xI$error <= 0.01]))\nt2 = max(xII$error[ xII$values < tau01 ])\n\n#Line 57\n#pdf(\"LinePlotTypeI+IIErrors.pdf\", width = 8, height = 6)\n\nlibrary(RColorBrewer)\ncols = brewer.pal(9, \"Set1\")[c(3, 4, 5)]\nplot(xII$error ~ xII$values,  type = \"l\", col = cols[1], lwd = 3,\n     xlim = c(-300, 250), ylim = c(0, 1),\n     xlab = \"Log Likelihood Ratio Values\", ylab=\"Error Rate\")\npoints(xI$error ~ xI$values, type = \"l\", col = cols[2], lwd = 3)\nlegend(x = 50, y = 0.4, fill = c(cols[2], cols[1]),\n       legend = c(\"Classify Ham as Spam\", \n                  \"Classify Spam as Ham\"), cex = 0.8,\n       bty = \"n\")\nabline(h=0.01, col =\"grey\", lwd = 3, lty = 2)\ntext(-250, 0.05, pos = 4, \"Type I Error = 0.01\", col = cols[2])\n\nmtext(tau01, side = 1, line = 0.5, at = tau01, col = cols[3])\nsegments(x0 = tau01, y0 = -.50, x1 = tau01, y1 = t2, \n         lwd = 2, col = \"grey\")\ntext(tau01 + 20, 0.05, pos = 4,\n     paste(\"Type II Error = \", round(t2, digits = 2)), \n     col = cols[1])\n\n#dev.off()\n\n#Line 58\nk = 5\nnumTrain = length(trainMsgWords)\npartK = sample(numTrain)\ntot = k * floor(numTrain/k)\npartK = matrix(partK[1:tot], ncol = k)\n\ntestFoldOdds = NULL\nfor (i in 1:k) {\n  foldIdx = partK[ , i]\n  trainTabFold = computeFreqs(trainMsgWords[-foldIdx], trainIsSpam[-foldIdx])\n  testFoldOdds = c(testFoldOdds, \n                   sapply(trainMsgWords[ foldIdx ], computeMsgLLR, trainTabFold))\n}\n\ntestFoldSpam = NULL\nfor (i in 1:k) {\n  foldIdx = partK[ , i]\n  testFoldSpam = c(testFoldSpam, trainIsSpam[foldIdx])\n}\n\nxFoldI = typeIErrorRates(testFoldOdds, testFoldSpam)\nxFoldII = typeIIErrorRates(testFoldOdds, testFoldSpam)\ntauFoldI = round(min(xFoldI$values[xFoldI$error <= 0.01]))\ntFold2 = xFoldII$error[ xFoldII$values < tauFoldI ]\n\nsmallNums = rep((1/2)^40, 2000000)\n\n#Line 59\nlargeNum = 10000\n\nprint(sum(smallNums), digits = 20)\n\nprint(largeNum + sum(smallNums), digits = 20)\n\nfor (i in 1:length(smallNums)) {\n  largeNum = largeNum + smallNums[i]\n}\nprint(largeNum, digits = 20)\n\nsampleSplit = lapply(sampleEmail, splitMessage)\n\nheader = sampleSplit[[1]]$header\nheader[1:12]\n\nheader[1] = sub(\"^From\", \"Top-From:\", header[1])\nheader[1]\n\n#Line 60\nheaderPieces = read.dcf(textConnection(header), all = TRUE)\n\nheaderPieces[, \"Delivered-To\"]\n\n\nheaderVec = unlist(headerPieces)\ndupKeys = sapply(headerPieces, function(x) length(unlist(x)))\nnames(headerVec) = rep(colnames(headerPieces), dupKeys)\n\nheaderVec[ which(names(headerVec) == \"Delivered-To\") ]\n\nlength(headerVec)\n\nlength(unique(names(headerVec)))\n\nprocessHeader = function(header)\n{\n  # modify the first line to create a key:value pair\n  header[1] = sub(\"^From\", \"Top-From:\", header[1])\n  \n  headerMat = read.dcf(textConnection(header), all = TRUE)\n  headerVec = unlist(headerMat)\n  \n  dupKeys = sapply(headerMat, function(x) length(unlist(x)))\n  names(headerVec) = rep(colnames(headerMat), dupKeys)\n  \n  return(headerVec)\n}\n\n#Line 61\nheaderList = lapply(sampleSplit, \n                    function(msg) {\n                      processHeader(msg$header)} )\n\ncontentTypes = sapply(headerList, function(header) \n  header[\"Content-Type\"])\nnames(contentTypes) = NULL\ncontentTypes\n\nhasAttach = grep(\"^ *multi\", tolower(contentTypes))\nhasAttach\n\nboundaries = getBoundary(contentTypes[ hasAttach ])\nboundaries\n\nboundary = boundaries[9]\nbody = sampleSplit[[15]]$body\n\nbString = paste(\"--\", boundary, sep = \"\")\nbStringLocs = which(bString == body)\nbStringLocs\n\neString = paste(\"--\", boundary, \"--\", sep = \"\")\neStringLoc = which(eString == body)\neStringLoc\n\ndiff(c(bStringLocs[-1], eStringLoc))\n\n#Line 62\n### This code has mistakes in it - and we fix them later!\nprocessAttach = function(body, contentType){\n  \n  boundary = getBoundary(contentType)\n  \n  bString = paste(\"--\", boundary, \"$\", sep = \"\")\n  bStringLocs = grep(bString, body)\n  \n  eString = paste(\"--\", boundary, \"--$\", sep = \"\")\n  eStringLoc = grep(eString, body)\n  \n  n = length(body)\n  \n  if (length(eStringLoc) == 0) eStringLoc = n + 1\n  if (length(bStringLocs) == 1) attachLocs = NULL\n  else attachLocs = c(bStringLocs[-1],  eStringLoc)\n  \n  msg = body[ (bStringLocs[1] + 1) : min(n, (bStringLocs[2] - 1), \n                                         na.rm = TRUE)]\n  \n  if ( eStringLoc < n )\n    msg = c(msg, body[ (eStringLoc + 1) : n ])\n  \n  if ( !is.null(attachLocs) ) {\n    attachLens = diff(attachLocs, lag = 1) \n    attachTypes = mapply(function(begL, endL) {\n      contentTypeLoc = grep(\"[Cc]ontent-[Tt]ype\", body[ (begL + 1) : (endL - 1)])\n      contentType = body[ begL + contentTypeLoc]\n      contentType = gsub('\"', \"\", contentType )\n      MIMEType = sub(\" *Content-Type: *([^;]*);?.*\", \"\\\\1\", contentType)\n      return(MIMEType)\n    }, attachLocs[-length(attachLocs)], attachLocs[-1])\n  }\n  \n  if (is.null(attachLocs)) return(list(body = msg, attachInfo = NULL) )\n  else return(list(body = msg, \n                   attachDF = data.frame(aLen = attachLens, \n                                         aType = attachTypes,\n                                         stringsAsFactors = FALSE)))                                \n}\n\n#Line 63\nbodyList = lapply(sampleSplit, function(msg) msg$body)\nattList = mapply(processAttach, bodyList[hasAttach], \n                 contentTypes[hasAttach], \n                 SIMPLIFY = FALSE)\n\nlens = sapply(attList, function(processedA) \n  processedA$attachDF$aLen)\nhead(lens)  # will cause an error with the first message. its ok.\nattList[[2]]$attachDF\n\nbody = bodyList[hasAttach][[2]]\nlength(body)\n\nbody[35:45]\n\n#Line 64\nprocessAttach = function(body, contentType){\n  \n  n = length(body)\n  boundary = getBoundary(contentType)\n  \n  bString = paste(\"--\", boundary, sep = \"\")\n  bStringLocs = which(bString == body)\n  eString = paste(\"--\", boundary, \"--\", sep = \"\")\n  eStringLoc = which(eString == body)\n  \n  if (length(eStringLoc) == 0) eStringLoc = n\n  if (length(bStringLocs) <= 1) {\n    attachLocs = NULL\n    msgLastLine = n\n    if (length(bStringLocs) == 0) bStringLocs = 0\n  } else {\n    attachLocs = c(bStringLocs[ -1 ],  eStringLoc)\n    msgLastLine = bStringLocs[2] - 1\n  }\n  \n  msg = body[ (bStringLocs[1] + 1) : msgLastLine] \n  if ( eStringLoc < n )\n    msg = c(msg, body[ (eStringLoc + 1) : n ])\n  \n  if ( !is.null(attachLocs) ) {\n    attachLens = diff(attachLocs, lag = 1) \n    attachTypes = mapply(function(begL, endL) {\n      CTloc = grep(\"^[Cc]ontent-[Tt]ype\", body[ (begL + 1) : (endL - 1)])\n      if ( length(CTloc) == 0 ) {\n        MIMEType = NA\n      } else {\n        CTval = body[ begL + CTloc[1] ]\n        CTval = gsub('\"', \"\", CTval )\n        MIMEType = sub(\" *[Cc]ontent-[Tt]ype: *([^;]*);?.*\", \"\\\\1\", CTval)   \n      }\n      return(MIMEType)\n    }, attachLocs[-length(attachLocs)], attachLocs[-1])\n  }\n  \n  if (is.null(attachLocs)) return(list(body = msg, attachDF = NULL) )\n  return(list(body = msg, \n              attachDF = data.frame(aLen = attachLens, \n                                    aType = unlist(attachTypes),\n                                    stringsAsFactors = FALSE)))                                \n}                       \n\nreadEmail = function(dirName) {\n  # retrieve the names of files in directory\n  fileNames = list.files(dirName, full.names = TRUE)\n  # drop files that are not email\n  notEmail = grep(\"cmds$\", fileNames)\n  if ( length(notEmail) > 0) fileNames = fileNames[ - notEmail ]\n  \n  # read all files in the directory\n  lapply(fileNames, readLines, encoding = \"latin1\")\n}\n\n#Line 65\nprocessAllEmail = function(dirName, isSpam = FALSE)\n{\n  # read all files in the directory\n  messages = readEmail(dirName)\n  fileNames = names(messages)\n  n = length(messages)\n  \n  # split header from body\n  eSplit = lapply(messages, splitMessage)\n  rm(messages)\n  \n  # process header as named character vector\n  headerList = lapply(eSplit, function(msg) \n    processHeader(msg$header))\n  \n  # extract content-type key\n  contentTypes = sapply(headerList, function(header) \n    header[\"Content-Type\"])\n  \n  # extract the body\n  bodyList = lapply(eSplit, function(msg) msg$body)\n  rm(eSplit)\n  \n  # which email have attachments\n  hasAttach = grep(\"^ *multi\", tolower(contentTypes))\n  \n  # get summary stats for attachments and the shorter body\n  attList = mapply(processAttach, bodyList[hasAttach], \n                   contentTypes[hasAttach], SIMPLIFY = FALSE)\n  \n  bodyList[hasAttach] = lapply(attList, function(attEl) \n    attEl$body)\n  \n  attachInfo = vector(\"list\", length = n )\n  attachInfo[ hasAttach ] = lapply(attList, \n                                   function(attEl) attEl$attachDF)\n  \n  # prepare return structure\n  emailList = mapply(function(header, body, attach, isSpam) {\n    list(isSpam = isSpam, header = header, \n         body = body, attach = attach)\n  },\n  headerList, bodyList, attachInfo, \n  rep(isSpam, n), SIMPLIFY = FALSE )\n  names(emailList) = fileNames\n  \n  invisible(emailList)\n}\n\n#Line 66\nemailStruct = mapply(processAllEmail, fullDirNames,\n                     isSpam = rep( c(FALSE, TRUE), 3:2))      \nemailStruct = unlist(emailStruct, recursive = FALSE)\n\nsampleStruct = emailStruct[ indx ]\n\nsave(emailStruct, file=\"emailXX.rda\")\n\nheader = sampleStruct[[1]]$header\nsubject = header[\"Subject\"]\nels = strsplit(subject, \"\")\nall(els %in% LETTERS)\n\ntestSubject = c(\"DEAR MADAME\", \"WINNER!\", \"\")\n\nels = strsplit(testSubject, \"\")\nsapply(els, function(subject) all(subject %in% LETTERS))\n\n\ngsub(\"[[:punct:] ]\", \"\", testSubject)\n\ngsub(\"[^[:alpha:]]\", \"\", testSubject)\n\n#Line 67\nisYelling = function(msg) {\n  if ( \"Subject\" %in% names(msg$header) ) {\n    el = gsub(\"[^[:alpha:]]\", \"\", msg$header[\"Subject\"])\n    if (nchar(el) > 0) \n      nchar(gsub(\"[A-Z]\", \"\", el)) < 1\n    else \n      FALSE\n  } else \n    NA\n}\n\nperCaps =\n  function(msg)\n  {\n    body = paste(msg$body, collapse = \"\")\n    \n    # Return NA if the body of the message is \"empty\"\n    if(length(body) == 0 || nchar(body) == 0) return(NA)\n    \n    # Eliminate non-alpha characters\n    body = gsub(\"[^[:alpha:]]\", \"\", body)\n    capText = gsub(\"[^A-Z]\", \"\", body)\n    100 * nchar(capText)/nchar(body)\n  }\n\n#Line 68\nsapply(sampleStruct, perCaps)\n\nfuncList = list( \n  isRe = function(msg) {\n    \"Subject\" %in% names(msg$header) &&\n      length(grep(\"^[ \\t]*Re:\", msg$header[[\"Subject\"]])) > 0\n  },\n  numLines = function(msg) \n    length(msg$body),\n  isYelling = function(msg) {\n    if ( \"Subject\" %in% names(msg$header) ) {\n      el = gsub(\"[^[:alpha:]]\", \"\", msg$header[\"Subject\"])\n      if (nchar(el) > 0) \n        nchar(gsub(\"[A-Z]\", \"\", el)) < 1\n      else \n        FALSE\n    }\n    else NA\n  },\n  perCaps = function(msg) {\n    body = paste(msg$body, collapse = \"\")\n    \n    # Return NA if the body of the message is \"empty\"\n    if(length(body) == 0 || nchar(body) == 0) return(NA)\n    \n    # Eliminate non-alpha characters\n    body = gsub(\"[^[:alpha:]]\", \"\", body)\n    capText = gsub(\"[^A-Z]\", \"\", body)\n    100 * nchar(capText)/nchar(body)\n  }\n)\n\n#Line 69\nlapply(funcList, function(func) \n  sapply(sampleStruct, function(msg) func(msg)))\n\ncreateDerivedDF =\n  function(email = emailStruct, operations = funcList, \n           verbose = FALSE)\n  {\n    els = lapply(names(operations),\n                 function(id) {\n                   if(verbose) print(id)\n                   e = operations[[id]]\n                   v = if(is.function(e)) \n                     sapply(email, e)\n                   else \n                     sapply(email, function(msg) eval(e))\n                   v\n                 })\n    \n    df = as.data.frame(els)\n    names(df) = names(operations)\n    invisible(df)\n  }\n\nsampleDF = createDerivedDF(sampleStruct)\nhead(sampleDF)\n\n#Line 70\nfuncList = list(\n  isSpam =\n    expression(msg$isSpam)\n  ,\n  isRe =\n    function(msg) {\n      # Can have a Fwd: Re:  ... but we are not looking for this here.\n      # We may want to look at In-Reply-To field.\n      \"Subject\" %in% names(msg$header) && \n        length(grep(\"^[ \\t]*Re:\", msg$header[[\"Subject\"]])) > 0\n    }\n  ,\n  numLines =\n    function(msg) length(msg$body)\n  ,\n  bodyCharCt =\n    function(msg)\n      sum(nchar(msg$body))\n  ,\n  underscore =\n    function(msg) {\n      if(!\"Reply-To\" %in% names(msg$header))\n        return(FALSE)\n      \n      txt <- msg$header[[\"Reply-To\"]]\n      length(grep(\"_\", txt)) > 0  && \n        length(grep(\"[0-9A-Za-z]+\", txt)) > 0\n    }\n  ,\n  subExcCt = \n    function(msg) {\n      x = msg$header[\"Subject\"]\n      if(length(x) == 0 || sum(nchar(x)) == 0 || is.na(x))\n        return(NA)\n      \n      sum(nchar(gsub(\"[^!]\",\"\", x)))\n    }\n  ,\n  subQuesCt =\n    function(msg) {\n      x = msg$header[\"Subject\"]\n      if(length(x) == 0 || sum(nchar(x)) == 0 || is.na(x))\n        return(NA)\n      \n      sum(nchar(gsub(\"[^?]\",\"\", x)))\n    }\n  ,\n  numAtt = \n    function(msg) {\n      if (is.null(msg$attach)) return(0)\n      else nrow(msg$attach)\n    }\n  \n  ,\n  priority =\n    function(msg) {\n      ans <- FALSE\n      # Look for names X-Priority, Priority, X-Msmail-Priority\n      # Look for high any where in the value\n      ind = grep(\"priority\", tolower(names(msg$header)))\n      if (length(ind) > 0)  {\n        ans <- length(grep(\"high\", tolower(msg$header[ind]))) >0\n      }\n      ans\n    }\n  ,\n  numRec =\n    function(msg) {\n      # unique or not.\n      els = getMessageRecipients(msg$header)\n      \n      if(length(els) == 0)\n        return(NA)\n      \n      # Split each line by \",\"  and in each of these elements, look for\n      # the @ sign. This handles\n      tmp = sapply(strsplit(els, \",\"), function(x) grep(\"@\", x))\n      sum(sapply(tmp, length))\n    }\n  ,\n  perCaps =\n    function(msg)\n    {\n      body = paste(msg$body, collapse = \"\")\n      \n      # Return NA if the body of the message is \"empty\"\n      if(length(body) == 0 || nchar(body) == 0) return(NA)\n      \n      # Eliminate non-alpha characters and empty lines \n      body = gsub(\"[^[:alpha:]]\", \"\", body)\n      els = unlist(strsplit(body, \"\"))\n      ctCap = sum(els %in% LETTERS)\n      100 * ctCap / length(els)\n    }\n  ,\n  isInReplyTo =\n    function(msg)\n    {\n      \"In-Reply-To\" %in% names(msg$header)\n    }\n  ,\n  sortedRec =\n    function(msg)\n    {\n      ids = getMessageRecipients(msg$header)\n      all(sort(ids) == ids)\n    }\n  ,\n  subPunc =\n    function(msg)\n    {\n      if(\"Subject\" %in% names(msg$header)) {\n        el = gsub(\"['/.:@-]\", \"\", msg$header[\"Subject\"])\n        length(grep(\"[A-Za-z][[:punct:]]+[A-Za-z]\", el)) > 0\n      }\n      else\n        FALSE\n    },\n  hour =\n    function(msg)\n    {\n      date = msg$header[\"Date\"]\n      if ( is.null(date) ) return(NA)\n      # Need to handle that there may be only one digit in the hour\n      locate = regexpr(\"[0-2]?[0-9]:[0-5][0-9]:[0-5][0-9]\", date)\n      \n      if (locate < 0)\n        locate = regexpr(\"[0-2]?[0-9]:[0-5][0-9]\", date)\n      if (locate < 0) return(NA)\n      \n      hour = substring(date, locate, locate+1)\n      hour = as.numeric(gsub(\":\", \"\", hour))\n      \n      locate = regexpr(\"PM\", date)\n      if (locate > 0) hour = hour + 12\n      \n      locate = regexpr(\"[+-][0-2][0-9]00\", date)\n      if (locate < 0) offset = 0\n      else offset = as.numeric(substring(date, locate, locate + 2))\n      (hour - offset) %% 24\n    }\n  ,\n  multipartText =\n    function(msg)\n    {\n      if (is.null(msg$attach)) return(FALSE)\n      numAtt = nrow(msg$attach)\n      \n      types = \n        length(grep(\"(html|plain|text)\", msg$attach$aType)) > (numAtt/2)\n    }\n  ,\n  hasImages =\n    function(msg)\n    {\n      if (is.null(msg$attach)) return(FALSE)\n      \n      length(grep(\"^ *image\", tolower(msg$attach$aType))) > 0\n    }\n  ,\n  isPGPsigned =\n    function(msg)\n    {\n      if (is.null(msg$attach)) return(FALSE)\n      \n      length(grep(\"pgp\", tolower(msg$attach$aType))) > 0\n    },\n  perHTML =\n    function(msg)\n    {\n      if(! (\"Content-Type\" %in% names(msg$header))) return(0)\n      \n      el = tolower(msg$header[\"Content-Type\"]) \n      if (length(grep(\"html\", el)) == 0) return(0)\n      \n      els = gsub(\"[[:space:]]\", \"\", msg$body)\n      totchar = sum(nchar(els))\n      totplain = sum(nchar(gsub(\"<[^<]+>\", \"\", els )))\n      100 * (totchar - totplain)/totchar\n    },\n  subSpamWords =\n    function(msg)\n    {\n      if(\"Subject\" %in% names(msg$header))\n        length(grep(paste(SpamCheckWords, collapse = \"|\"), \n                    tolower(msg$header[\"Subject\"]))) > 0\n      else\n        NA\n    }\n  ,\n  subBlanks =\n    function(msg)\n    {\n      if(\"Subject\" %in% names(msg$header)) {\n        x = msg$header[\"Subject\"]\n        # should we count blank subject line as 0 or 1 or NA?\n        if (nchar(x) == 1) return(0)\n        else 100 *(1 - (nchar(gsub(\"[[:blank:]]\", \"\", x))/nchar(x)))\n      } else NA\n    }\n  ,\n  noHost =\n    function(msg)\n    {\n      # Or use partial matching.\n      idx = pmatch(\"Message-\", names(msg$header))\n      \n      if(is.na(idx)) return(NA)\n      \n      tmp = msg$header[idx]\n      return(length(grep(\".*@[^[:space:]]+\", tmp)) ==  0)\n    }\n  ,\n  numEnd =\n    function(msg)\n    {\n      # If we just do a grep(\"[0-9]@\",  )\n      # we get matches on messages that have a From something like\n      # \" \\\"marty66@aol.com\\\" <synjan@ecis.com>\"\n      # and the marty66 is the \"user's name\" not the login\n      # So we can be more precise if we want.\n      x = names(msg$header)\n      if ( !( \"From\" %in% x) ) return(NA)\n      login = gsub(\"^.*<\", \"\", msg$header[\"From\"])\n      if ( is.null(login) ) \n        login = gsub(\"^.*<\", \"\", msg$header[\"X-From\"])\n      if ( is.null(login) ) return(NA)\n      login = strsplit(login, \"@\")[[1]][1]\n      length(grep(\"[0-9]+$\", login)) > 0\n    },\n  isYelling =\n    function(msg)\n    {\n      if ( \"Subject\" %in% names(msg$header) ) {\n        el = gsub(\"[^[:alpha:]]\", \"\", msg$header[\"Subject\"])\n        if (nchar(el) > 0) nchar(gsub(\"[A-Z]\", \"\", el)) < 1\n        else FALSE\n      }\n      else\n        NA\n    },\n  forwards =\n    function(msg)\n    {\n      x = msg$body\n      if(length(x) == 0 || sum(nchar(x)) == 0)\n        return(NA)\n      \n      ans = length(grep(\"^[[:space:]]*>\", x))\n      100 * ans / length(x)\n    },\n  isOrigMsg =\n    function(msg)\n    {\n      x = msg$body\n      if(length(x) == 0) return(NA)\n      \n      length(grep(\"^[^[:alpha:]]*original[^[:alpha:]]+message[^[:alpha:]]*$\", \n                  tolower(x) ) ) > 0\n    },\n  isDear =\n    function(msg)\n    {\n      x = msg$body\n      if(length(x) == 0) return(NA)\n      \n      length(grep(\"^[[:blank:]]*dear +(sir|madam)\\\\>\", \n                  tolower(x))) > 0\n    },\n  isWrote =\n    function(msg)\n    {\n      x = msg$body\n      if(length(x) == 0) return(NA)\n      \n      length(grep(\"(wrote|schrieb|ecrit|escribe):\", tolower(x) )) > 0\n    },\n  avgWordLen =\n    function(msg)\n    {\n      txt = paste(msg$body, collapse = \" \")\n      if(length(txt) == 0 || sum(nchar(txt)) == 0) return(0)\n      \n      txt = gsub(\"[^[:alpha:]]\", \" \", txt)\n      words = unlist(strsplit(txt, \"[[:blank:]]+\"))\n      wordLens = nchar(words)\n      mean(wordLens[ wordLens > 0 ])\n    }\n  ,\n  numDlr =\n    function(msg)\n    {\n      x = paste(msg$body, collapse = \"\")\n      if(length(x) == 0 || sum(nchar(x)) == 0)\n        return(NA)\n      \n      nchar(gsub(\"[^$]\",\"\", x))\n    }\n)\n\n#Line 71\nSpamCheckWords =\n  c(\"viagra\", \"pounds\", \"free\", \"weight\", \"guarantee\", \"million\", \n    \"dollars\", \"credit\", \"risk\", \"prescription\", \"generic\", \"drug\",\n    \"financial\", \"save\", \"dollar\", \"erotic\", \"million\", \"barrister\",\n    \"beneficiary\", \"easy\", \n    \"money back\", \"money\", \"credit card\")\n\n\ngetMessageRecipients =\n  function(header)\n  {\n    c(if(\"To\" %in% names(header))  header[[\"To\"]] else character(0),\n      if(\"Cc\" %in% names(header))  header[[\"Cc\"]] else character(0),\n      if(\"Bcc\" %in% names(header)) header[[\"Bcc\"]] else character(0)\n    )\n  }\n\nsampleDF = createDerivedDF(sampleStruct)\nhead(sampleDF)\n\n#To remove error: 'getCharCE' must be called on a CHARSXP\n#Installing packages Rcpp, RcppParallel, digest\nSys.setlocale(\"LC_ALL\", \"C\")\nlibrary(Rcpp)\nlibrary(RcppParallel)\nlibrary(digest)\ndev.off()\nemailDF = createDerivedDF(emailStruct)\ndim(emailDF)\n\n#save(emailDF, file = \"spamAssassinDerivedDF.rda\")\n\n#Line 72\ndim(emailDF)\n\nperCaps2 =\n  function(msg)\n  {\n    body = paste(msg$body, collapse = \"\")\n    \n    # Return NA if the body of the message is \"empty\"\n    if(length(body) == 0 || nchar(body) == 0) return(NA)\n    \n    # Eliminate non-alpha characters and empty lines \n    body = gsub(\"[^[:alpha:]]\", \"\", body)\n    els = unlist(strsplit(body, \"\"))\n    ctCap = sum(els %in% LETTERS)\n    100 * ctCap / length(els)\n  }\n",
    "created" : 1538924269751.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "505669303",
    "id" : "EAE86B33",
    "lastKnownWriteTime" : 1538926975,
    "last_content_update" : 1538926975993,
    "path" : "~/Desktop/SMU/QTW/Week5/SpamFinder-RM.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled5"
    },
    "relative_order" : 15,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}